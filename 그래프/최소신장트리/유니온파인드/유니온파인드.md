# 유니온파인드 (Union-Find)

## 개념
- **서로소 집합(Disjoint Set)** 을 관리하는 자료구조
- 여러 원소들이 어떤 집합에 속해 있는지를 빠르게 관리함
- **Find**: 어떤 원소가 속한 집합의 대표(root)를 찾는다
- **Union**: 두 집합을 하나로 합친다

## 사용 상황
- 두 원소가 같은 집합에 속해 있는지 빠르게 판단할 때
- 그래프에서 사이클 발생 여부를 판별할 때
- 최소신장트리의 크루스칼 알고리즘 구현 시

## 구현 포인트
#### 1. Find (대표 찾기)
```java
static int find(int x) {
    if (parent[x] == x) return x;
    return find(parent[x]);
}
```

> **경로 압축 (Path Compression)**
> - find 하면서 부모를 루트로 바로 연결 
> - 트리 높이를 극단적으로 줄임

```java
static int find(int x) {
    if (parent[x] != x) {
        parent[x] = find(parent[x]);
    }
    return parent[x];
}
```

#### 2. Union (집합 합치기)
```java
static void union(int a, int b) {
    int rootA = find(a);
    int rootB = find(b);

    if (rootA == rootB) return; // 이미 같은 집합

    parent[rootB] = rootA;
}
```

> **랭크/크기 기반 Union**
> - 트리가 한쪽으로 치우치는 걸 방지

```java
static int[] rank; // 이 집합 트리가 얼마나 깊을 수 있는지에 대한 추정값

static void union(int a, int b) {
    int rootA = find(a);
    int rootB = find(b);

    if (rootA == rootB) return;

    if (rank[rootA] < rank[rootB]) {
        parent[rootA] = rootB;
    } else {
        parent[rootB] = rootA;
        if (rank[rootA] == rank[rootB]) {
            rank[rootA]++;
        }
    }
}
```

## 시간복잡도
- **O(1)**

## 실수 포인트
- find 없이 바로 parent 비교
- union 전에 root 비교 안 함
- parent 초기화 안 함
- 방향성 그래프에 사용하려 함

## 대표 문제
- [백준 1717 집합의 표현](https://www.acmicpc.net/problem/1717)
- [백준 1976 여행 가자](https://www.acmicpc.net/problem/1976)
- [백준 4195 친구 네트워크](https://www.acmicpc.net/problem/4195)
- [백준 20040 사이클 게임](https://www.acmicpc.net/problem/20040)
- [백준 4803 트리](https://www.acmicpc.net/problem/4803)