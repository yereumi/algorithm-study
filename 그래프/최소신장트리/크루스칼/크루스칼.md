# 크루스칼 (Kruskal)

## 개념
- **최소신장트리(MST)** 를 구하는 알고리즘
- 간선을 가중치 오름차순으로 정렬한 뒤 사이클이 생기지 않는 간선만 선택하여 트리를 구성

## 사용 상황
- 그래프의 모든 정점을 연결해야 할 때
- 전체 비용의 합을 최소화하고 싶을 때
- 간선 정보가 명확하게 주어질 때

- ❌ 사용 불가
  - A&rarr; B 최단 거리 (다익스트라)
  - 특정 시작점 기준 거리 문제

## 구현 포인트
#### 1.	모든 간선을 가중치 오름차순 정렬

#### 2.	각 정점을 자기 자신만의 집합으로 초기화
- 유니온 파인드 초기화
```java
parent = new int[n + 1];
for (int i = 1; i <= n; i++) {
	parent[i] = i;
}
```

#### 3.	간선을 하나씩 확인
- 두 정점이 같은 집합이면 &rarr; 사이클 ❌ &rarr; skip
- 다른 집합이면 &rarr; 선택 ⭕ &rarr; union

#### 4.	선택한 간선이 V-1개가 되면 종료

> **왜 유니온-파인드가 필요한가?**
> 
> 간선 (u, v)를 선택하려 할 때, 이미 u와 v가 연결돼 있나를 빠르게 판단해야 함
> 
> &rarr; 그 역할을 하는 게 **유니온–파인드** (O(1))

## 시간복잡도
- **O(E log E)**

&rarr; 정점보다 간선 수가 적을 때 특히 유리

## 실수 포인트
- 다익스트라랑 헷갈림
- 사이클 체크 안 함
- 간선 V-1개 전에 끝냄
- union 전에 find 안 함

## 대표 문제
- [백준 1197 최소 스패닝 트리](https://www.acmicpc.net/problem/1197)
- [백준 1922 네트워크 연결](https://www.acmicpc.net/problem/1922)
- [백준 1647 도시 분할 계획](https://www.acmicpc.net/problem/1647)
- [백준 4386 별자리 만들기](https://www.acmicpc.net/problem/4386)