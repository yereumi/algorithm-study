# 프림 (Prim)

## 개념
- **최소신장트리(MST)** 를 구하는 알고리즘
- 하나의 정점에서 시작하여 현재 트리에 연결될 수 있는 간선 중 가중치가 가장 작은 간선을 선택하며 트리를 확장

## 사용 상황
- 그래프의 모든 정점을 연결해야 할 때
- 전체 비용의 합을 최소화하고 싶을 때
- 정점 수가 많고, 인접 리스트로 그래프가 주어질 때

- ❌ 사용 불가
    - A&rarr; B 최단 거리 (다익스트라)
    - 특정 경로의 최단 거리 문제

## 구현 포인트
#### 1.	임의의 시작 정점 선택
- MST는 시작점에 영향을 받지 않음
- 보통 1번 정점부터 시작

#### 2.	방문 여부 배열 사용
- 이미 MST에 포함된 정점인지 판단
- 사이클 방지 역할

```java
boolean[] visited = new boolean[V + 1];
```

#### 3.	우선순위 큐 사용
- 현재 MST에서 나갈 수 있는 간선 중 최소 비용 간선을 선택

```java
PriorityQueue<int[]> pq = new PriorityQueue<>(
    (o1, o2) -> o1[1] - o2[1]
); // {정점, 비용}
```

#### 4.	MST 확장
방문하지 않은 정점이면
- MST에 포함
- 해당 정점에서 나가는 간선을 PQ에 추가

#### 5. 모든 정점이 선택되면 종료
- 선택된 정점 수가 V가 되면 끝
- (또는 간선 수가 V-1개)

> **왜 유니온-파인드가 필요없을까?**
>
> - 프림은 트리 내부 정점 &rarr; 외부 정점으로만 확장
> - 구조상 사이클이 생길 수 없음 
> - 방문 배열만으로 충분

## 시간복잡도
- 배열 기반: **O(V²)**
- 우선순위 큐: **O(E log V)**

&rarr; 정점이 많고 간선이 많은 그래프에서 유리

## 실수 포인트
- visited 체크 안 해서 사이클 발생
- PQ에 넣을 때 이미 방문한 정점 고려 안 함
- MST 완성 조건(V개 정점)을 잘못 판단
- 다익스트라처럼 거리 배열을 두고 헷갈림

## 대표 문제
- [백준 1197 최소 스패닝 트리](https://www.acmicpc.net/problem/1197)
- [백준 1922 네트워크 연결](https://www.acmicpc.net/problem/1922)
- [백준 16398 행성 연결](https://www.acmicpc.net/problem/16398)
- [백준 4386 별자리 만들기](https://www.acmicpc.net/problem/4386)